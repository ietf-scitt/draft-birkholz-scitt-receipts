---
title: Countersigning Receipts in Support of Trustworthy Supply Chain Ledger Services
abbrev: SCITT Receipts
docname: draft-birkholz-scitt-receipts-latest
stand_alone: true
ipr: trust200902
area: Security
wg: TBD
kw: Internet-Draft
cat: std
pi:
  toc: yes
  sortrefs: yes
  symrefs: yes

author:
- ins: H. Birkholz
  name: Henk Birkholz
  org: Fraunhofer SIT
  abbrev: Fraunhofer SIT
  email: henk.birkholz@sit.fraunhofer.de
  street: Rheinstrasse 75
  code: '64295'
  city: Darmstadt
  country: Germany
- ins: M. Riechert
  name: Maik Riechert
  organization: Microsoft
  email: Maik.Riechert@microsoft.com
  country: UK
- ins: A. Delignat
  name: Antoine Delignat
  organization: Microsoft
  email: antdl@microsoft.com
  country: UK

normative:
  RFC8949:
  RFC9162:
  RFC6234:
  RFC8032:
  RFC6979:

informative:
  I-D.ietf-cose-countersign:

--- abstract

A transparent and authentic ledger service in support of a supply chain's integrity, transparency, and trust requires all peers that contribute to the ledgers operations to be trustworthy and authentic. In this document, a countersigning variant is specified that enables trust assertions on merkle-tree based operations for global supply chain ledgers. A generic procedure how to produce payloads for signing and validation is defined and leverages solutions and principles from the Concise Signing and Encryption (COSE) space.

--- middle

# Introduction

This document defines a method for countersigning of COSE_Sign1 messages when using Merkle Trees.

## Requirements Notation

{::boilerplate bcp14-tagged}

{: #mybody}

# Common Parameters

A Transparency Service backed by a Merkle tree is defined by a collection of immutable parameters, which are used by clients to communicate with the service and to verify artifacts. Each of these parameters must be established before the service operator begins to operate the service. At minimum, the following must be defined:

- Service identifier: An opaque identifier (e.g. UUID) that uniquely identifies the service and all other parameters.

- Tree algorithm: The tree algorithm used. This document creates a registry (see {{tree-alg-registry}}) with an initial set of tree algorithms that are described in this document.

Additional parameters may be defined depending on the tree algorithm used.

# Basic Receipt Structure

A receipt represents a countersignature produced by a Transparency Service.
The receipt structure is a CBOR array. The fields of the array in order are:

- service_id: The service identifier as tstr.

- contents: The receipt contents as a CBOR structure determined by the tree algorithm.

~~~ cddl
Receipt = [
  service_id: tstr,
  contents: any
]
~~~

Each tree algorithm must define the type of contents and how to generate and verify a receipt.

# COSE_Sign1 Countersigning    {#cose_sign1_countersign}

In this document, the structures and principles of COSE_Sign1 countersigning V2 ({{I-D.ietf-cose-countersign}}) are used.

In order to create a signature, a well-defined byte string is needed.
Since Merkle tree signing is applied over multiple messages to be countersigned, the Countersign_structure defined in {{I-D.ietf-cose-countersign}} forms just a part of this well-defined byte string but is used unchanged:

~~~ cddl
Countersign_structure = [
    context: "CounterSignatureV2",
    body_protected: empty_or_serialized_map,
    sign_protected: empty_or_serialized_map,
    external_aad: bstr,
    payload: bstr,
    other_fields: [
        signature: bstr
    ]
]
~~~

body_protected, payload, and signature are of the target COSE_Sign1 message. sign_protected is from the signer. external_aad is always empty (a zero-length byte string).

The sign_protected field is embedded in the receipt contents to be able to re-construct Countersign_structure during validation. This is part of the definition of the tree algorithm.

Procedure for reconstruction of Countersign_structure:

1. Let Target be the COSE_Sign1 message that corresponds to the countersignature. Different environments will have different mechanisms to achieve this. One obvious mechanism is to embed the receipt in the unprotected header of Target. Another mechanism may be to store both artifacts separately and use a naming convention, database, or other method to link both together.

2. Extract body_protected, payload, and signature from Target.

3. Create a Countersign_structure using the extracted fields from Target, and sign_protected from the receipt contents.

# CCF 2 Tree Algorithm

The CCF 2 tree algorithm corresponds to the algorithm implemented in the CCF version 2 framework.

## Additional Parameters        {#parameters}

The following additional service parameters are defined:

Hash Algorithm: The hash algorithm used for the Merkle Tree (see {{hash-alg-registry}}).

Signature Algorithm: The signature algorithm used (see {{sig-alg-registry}}).

Service Certificate: The X.509 certificate used as trust anchor to verify signatures generated by the transparency service.

## Cryptographic Components

### Merkle Trees

See {{Section 2.1 of RFC9162}}.

### Definition of the Merkle Tree    {#merkle-tree-def}

Note: This is a copy of {{Section 2.1.1 of RFC9162}} except that the Merkle Tree Hash algorithm treats leaves and intermediate nodes the same during hashing.

The ledger uses a binary Merkle Tree for efficient auditing. The hash algorithm used is one of the service's parameters (see Section {{parameters}}). This document establishes a registry of acceptable hash algorithms (see {{hash-alg-registry}}). Throughout this document, the hash algorithm in use is referred to as HASH and the size of its output in bytes is referred to as HASH_SIZE. The input to the Merkle Tree Hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle Tree. The output is a single HASH_SIZE Merkle Tree Hash. Given an ordered list of n inputs, D_n = \{d\[0\], d\[1\], ..., d\[n-1\]\}, the Merkle Tree Hash (MTH) is thus defined as follows:

The hash of an empty list is the hash of an empty string:

~~~
MTH({}) = HASH().
~~~

The hash of a list with one entry (also known as a leaf hash) is:

~~~
MTH({d[0]}) = HASH(d[0]).
~~~

For n > 1, let k be the largest power of two smaller than n (i.e., k < n <= 2k). The Merkle Tree Hash of an n-element list D_n is then defined recursively as:

~~~
MTH(D_n) = HASH(MTH(D[0:k]) || MTH(D[k:n])),
~~~

where:

- \|\| denotes concatenation
- : denotes concatenation of lists
- D\[k1:k2\] = D'_(k2-k1) denotes the list \{d'\[0\] = d\[k1\], d'\[1\] = d\[k1+1\], ..., d'\[k2-k1-1\] = d\[k2-1\]\} of length (k2 - k1).

The Merkle Tree Hash over D_n is also called the tree root hash.

### Merkle Inclusion Proofs

Note: This is a copy of {{Section 2.1.3 of RFC9162}}.

A Merkle inclusion proof for a leaf in a Merkle Tree is the shortest list of additional nodes in the Merkle Tree required to compute the Merkle Tree Hash for that tree. Each node in the tree is either a leaf node or is computed from the two nodes immediately below it (i.e., towards the leaves). At each step up the tree (towards the root), a node from the inclusion proof is combined with the node computed so far. In other words, the inclusion proof consists of the list of missing nodes required to compute the nodes leading from a leaf to the root of the tree. If the root computed from the inclusion proof matches the true root, then the inclusion proof proves that the leaf exists in the tree.

#### Generating an Inclusion Proof

Given an ordered list of n inputs to the tree, D_n = \{d\[0\], d\[1\], ..., d\[n-1\]\}, the Merkle inclusion proof PATH(m, D_n) for the (m+1)th input d\[m\], 0 <= m < n, is defined as follows:

[TODO] add pseudo-code to generate array of \[left, hash\] pairs given a list of leaves and a target leaf index

#### Verifying an Inclusion Proof

When a client has received an inclusion proof and wishes to verify inclusion of a leaf_hash for a given root_hash, the following algorithm may be used to prove the hash was included in the root_hash:

~~~
compute_root(leaf_hash, proof):
  h := leaf_hash
  for [left, hash] in proof:
      h := HASH(hash + h) if left
           HASH(h + hash) else
  return h

verify_proof(leaf_hash, root_hash, proof):
  h = compute_root(leaf_hash, proof)
  return h == root_hash
~~~

Note: compute_root is used in receipt verification where the computed root is validated indirectly by verifying the signature over the root.

### Signing of the tree root

A tree root is signed by signing over the tree root hash bytes using the signature algorithm declared in the service's parameters (see {{parameters}}). For example, the signing payload would be 32 bytes for a SHA-256 tree root hash.

## Merkle Tree Leaves

In general, a Transparency Service backed by a Merkle tree will have different types of leaves. In the following, the structure of those leaves used for countersigning is described. Note that the tree root signing operation is agnostic to any specific leaf content since each leaf is seen as an opaque byte stream. In this document, receipts are defined for countersigning leaves.

The content of a countersigning leaf is defined as the concatenation of three byte streams:

1. the hash of the CCF write set (see [TBD]), where write set is an opaque byte stream that is the serialization of CCF state changes,

2. the hash of the CCF commit evidence (see [TBD]), where commit evidence is an ASCII byte stream with additional information on the commitment of the transaction in the CCF ledger,

3. the hash of the CBOR-encoded Countersign_structure, using the CBOR encoding described in {{deterministic-cbor}}.

For all hashes, the Merkle Tree Hash Algorithm found in the service's parameters (see {{parameters}}) is used.

~~~
LeafBytes = HASH(write_set) + HASH(commit_evidence) + HASH(cbor(Countersign_structure))
~~~

## Receipt Contents Structure

The Receipt contents structure is a CBOR array. The fields of the array in order are:

- signature: The signature over the Merkle tree root as bstr.

- node_certificate: DER-encoded X.509 certificate of the CCF node that generated the signature. A node certificate is endorsed by the service certificate.

- inclusion_proof: The Merkle proof for the leaf as an array of \[left, hash\] pairs.

- leaf_info: Information about the leaf that is needed to reconstruct the leaf bytes: the hash of the CCF write set, the CCF commit evidence, and the protected header of the countersigner.

The CDDL fragment that represents the above text follows.

~~~ cddl
ReceiptContents = [
    signature: bstr,
    node_certificate: bstr,
    inclusion_proof: [+ ProofElement],
    leaf_info: LeafInfo
]

ProofElement = [
    left: bool
    hash: bstr
]

LeafInfo = [
    write_set_hash: bstr,
    commit_evidence: tstr,
    sign_protected: empty_or_serialized_map
]
~~~

## Receipt Generation

The following steps must be followed to generate a receipt after the tree root has been signed:

1. Let LEAF be the countersigning leaf in the Merkle tree for which a receipt should be generated.

2. Let ROOT_HASH be the root hash of the Merkle tree that contains LEAF, and SIGNATURE the signature over this root.

3. Compute LEAF_HASH as the hash of LEAF.

4. Generate an inclusion proof from LEAF_HASH to ROOT_HASH.

5. Construct a LeafInfo structure with the CCF write set hash, the commit evidence, and the protected header parameters of the countersigner.

6. Create a ReceiptContents structure and fill it with SIGNATURE, the node's signing certificate endorsed by the service certificate, the inclusion proof, and the LeafInfo.

7. Create a Receipt structure and fill it with the service identifier and ReceiptContents.

## Receipt Verification

The following steps must be followed to verify a Receipt:

1. Construct a Countersign_structure according to {{cose_sign1_countersign}}, using sign_protected from the leaf_info field of the receipt contents.

2. Compute LeafBytes as concatenation of the write set hash, the hash of the commit evidence, and the hash of the CBOR-encoding of Countersign_structure, using the Merkle Tree Hash Algorithm found in the service's parameters (see {{parameters}}) and the CBOR encoding described in {{deterministic-cbor}}.

        LeafBytes := write_set_hash + HASH(commit_evidence) + HASH(cbor(Countersign_structure))

4. Compute the leaf hash from LeafBytes using the Merkle Tree Hash Algorithm found in the service's parameters (see {{parameters}}).

        LeafHash := HASH(LeafBytes)

5. Compute the root hash from the leaf hash and the Merkle proof using the Merkle Tree Hash Algorithm found in the service's parameters (see {{parameters}}):

        root := compute_root(LeafHash, proof)

6. Verify the signature with the root hash as payload using the certificate chain established by the node certificate embedded in the receipt and the service certificate part of the service's parameters (see {{parameters}}).

# CBOR Encoding Restrictions    {#deterministic-cbor}

In order to always regenerate the same byte string for the "to be signed" and "to be hashed" values, the core deterministic encoding rules defined in {{Section 4.2.1 of RFC8949}} MUST be used.

# Privacy Considerations

Privacy Considerations

# Security Considerations

Security Considerations

# IANA Considerations

## Additions to Existing Registries

### New Entry to the COSE Header Parameters Registry

IANA is requested to register the new COSE Header parameter defined below in the "COSE Header Parameters" registry. The new parameter is used for embedding one or more COSE_Sign1 Countersign Receipts in the unprotected header of a COSE message.

Name: COSE_Sign1 Countersign receipt

Label: TBD

Value Type: Receipt / \[+ Receipt\]

Description: A COSE_Sign1 Countersign Receipt to be embedded in the unprotected header of the countersigned COSE_Sign1 message.

## New SCITT-Related Registries

IANA is asked to add a new registry "TBD" to the list that appears at https://www.iana.org/assignments/.

The rest of this section defines the subregistries that are to be created within the new "TBD" registry.

### Tree Algorithms    {#tree-alg-registry}

IANA is asked to establish a registry of tree algorithm identifiers, named "Tree Algorithms", with the following registration procedures: TBD

The "Tree Algorithms" registry initially consists of:

| Identifier | Tree Algorithm       | Reference     |
| CCF-2      | CCF 2 tree algorithm | This document |
{: title="Initial content of Tree Algorithms registry"}

The designated expert(s) should ensure that the proposed algorithm has a public specification and is suitable for use as [TBD].

### Hash Algorithms    {#hash-alg-registry}

IANA is asked to establish a registry of hash algorithm identifiers, named "Hash Algorithms", with the following registration procedures: TBD

The "Hash Algorithms" registry initially consists of:

| Identifier | Hash Algorithm | Reference   |
| SHA-256    | SHA-256        | {{RFC6234}} |
{: title="Initial content of Hash Algorithms registry"}

The designated expert(s) should ensure that the proposed algorithm has a public specification and is suitable for use as a cryptographic hash algorithm with no known preimage or collision attacks. These attacks can damage the integrity of the ledger.

### Signature Algorithms     {#sig-alg-registry}

IANA is asked to establish a registry of signature algorithm identifiers, named "Signature Algorithms", with the following registration procedures: TBD

The "Signature Algorithms" registry initially consists of:

| Identifier | Signature Algorithm | Reference |
| ES256      | Deterministic ECDSA (NIST P-256) with HMAC-SHA256 | {{RFC6979}} |
| ED25519    | Ed25519 (PureEdDSA with the edwards25519 curve)  | {{RFC8032}} |
{: title="Initial content of Signature Algorithms registry"}

The designated expert(s) should ensure that the proposed algorithm has a public specification and is suitable for use as a cryptographic signature algorithm.

--- back

