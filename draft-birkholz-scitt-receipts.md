---
title: Countersigning Receipts in Support of Trustworthy Supply Chain Ledger Services
abbrev: SCITT Receipts
docname: draft-birkholz-scitt-receipts-latest
stand_alone: true
ipr: trust200902
area: Security
wg: TBD
kw: Internet-Draft
cat: std
pi:
  toc: yes
  sortrefs: yes
  symrefs: yes

author:
- ins: H. Birkholz
  name: Henk Birkholz
  org: Fraunhofer SIT
  abbrev: Fraunhofer SIT
  email: henk.birkholz@sit.fraunhofer.de
  street: Rheinstrasse 75
  code: '64295'
  city: Darmstadt
  country: Germany
- ins: M. Riechert
  name: Maik Riechert
  organization: Microsoft
  email: Maik.Riechert@microsoft.com
  country: UK
- ins: A. Delignat
  name: Antoine Delignat
  organization: Microsoft
  email: antdl@microsoft.com
  country: UK

normative:
  RFC8949:
  RFC9162:
  RFC6234:
  RFC8032:
  RFC6979:

informative:
  I-D.ietf-cose-countersign:

--- abstract

A transparent and authentic ledger service in support of a supply chain's integrity, transparency, and trust requires all peers that contribute to the ledgers operations to be trustworthy and authentic. In this document, a countersigning variant is specified that enables trust assertions on merkle-tree based operations for global supply chain ledgers. A generic procedure how to produce payloads for signing and validation is defined and leverages solutions and principles from the Concise Signing and Encryption (COSE) space.

--- middle

# Introduction

This document defines a method for countersigning of COSE_Sign1 messages when using Merkle Trees.

## Requirements Notation

{::boilerplate bcp14-tagged}

{: #mybody}

# Cryptographic Components

## Merkle Trees

See {{Section 2.1 of RFC9162}}.

## Definition of the Merkle Tree    {#merkle-tree-def}

Note: This is a copy of {{Section 2.1.1 of RFC9162}} except that the Merkle Tree Hash algorithm currently treats leaves and intermediate nodes the same during hashing.

The log uses a binary Merkle Tree for efficient auditing. The hash algorithm used is one of the log's parameters (see Section {{parameters}}). This document establishes a registry of acceptable hash algorithms (see {{hash-alg-registry}}). Throughout this document, the hash algorithm in use is referred to as HASH and the size of its output in bytes is referred to as HASH_SIZE. The input to the Merkle Tree Hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle Tree. The output is a single HASH_SIZE Merkle Tree Hash. Given an ordered list of n inputs, D_n = \{d\[0\], d\[1\], ..., d\[n-1\]\}, the Merkle Tree Hash (MTH) is thus defined as follows:

The hash of an empty list is the hash of an empty string:

~~~
MTH({}) = HASH().
~~~

The hash of a list with one entry (also known as a leaf hash) is:

~~~
MTH({d[0]}) = HASH(d[0]).
~~~

For n > 1, let k be the largest power of two smaller than n (i.e., k < n <= 2k). The Merkle Tree Hash of an n-element list D_n is then defined recursively as:

~~~
MTH(D_n) = HASH(MTH(D[0:k]) || MTH(D[k:n])),
~~~

where:

- \|\| denotes concatenation
- : denotes concatenation of lists
- D\[k1:k2\] = D'_(k2-k1) denotes the list \{d'\[0\] = d\[k1\], d'\[1\] = d\[k1+1\], ..., d'\[k2-k1-1\] = d\[k2-1\]\} of length (k2 - k1).

The Merkle Tree Hash over D_n is also called the tree root hash.

## Signing of the tree root

A tree root is signed by signing over the tree root hash bytes using the signature algorithm declared in the Log's parameters (see {{parameters}}). For example, the signing payload would be 32 bytes for a SHA-256 tree root hash.

Comparison: {{Section 4.10 of RFC9162}}, which signs over the timestamp, tree size, root, and optional extensions using a DER-encoded structure. A future version of this draft may extend the information over which the signature is computed if necessary.

# Log Parameters        {#parameters}

A log is defined by a collection of immutable parameters which are used by clients to verify receipts (see {{receipts}}). Each of these parameters MUST be established before the log operator begins to operate the log.

Hash Algorithm: The hash algorithm used for the Merkle Tree (see {{hash-alg-registry}}).

Signature Algorithm: The signature algorithm used (see {{sig-alg-registry}}).

Certificate: The certificate used as trust anchor to verify signatures generated by the log.

Version: The version of the protocol supported by the log (currently 1).

[TODO] need a Log ID

# Merkle Tree Leaves

The content of a leaf is defined as the concatenation of an implementation-specific prefix byte stream and a CBOR-encoded LeafEntry structure:

~~~
LeafBytes = prefix + LeafEntryBytes
~~~

LeafEntryBytes is created by encoding LeafEntry to a byte string, using the encoding described in {{deterministic-cbor}}.

LeafEntry is a structure that contains the entry type and type-specific data:

~~~ cddl
LeafEntry = [
    type: LeafEntryType,
    data: LeafEntryData
]
LeafEntryType = int
LeafEntryData = any
~~~

Comparison: See {{Section 4.5 of RFC9162}} where leaves are represented as a DER-encoded structure containing type, and type-dependent data.

A specification of a leaf entry type must define the following:

- The value of LeafEntryType
- The type of LeafEntryData
- The type of LeafReceiptData, which defines what to include in a receipt (see {{receipts}})
- A procedure to re-construct the value of LeafEntryData

~~~ cddl
LeafReceiptData = any
~~~

## COSE_Sign1 Countersign type

LeafEntryType value: 1

LeafEntryData type: Countersign_structure

LeafReceiptData type: SignerData

~~~ cddl
Countersign_structure = [
    context: "CounterSignatureV2",
    body_protected: empty_or_serialized_map,
    sign_protected: empty_or_serialized_map,
    external_aad: bstr,  ; always empty
    payload: bstr,
    other_fields: [
        signature: bstr
    ]
]

SignerData = [
    sign_protected: empty_or_serialized_map
]
~~~

body_protected, payload, and signature are of the target COSE_Sign1 message. sign_protected is from the signer within the DerivationInfo structure. external_aad is externally supplied data from the application encoded in a bstr. If this field is not supplied, it defaults to a zero-length byte string.

Comparison: Countersign_structure is identical to COSE V2 countersigning in {{I-D.ietf-cose-countersign}}.

Procedure for reconstruction of LeafEntryData:

1. Let Target be the COSE_Sign1 message that corresponds to the countersignature. Different environments will have different mechanisms to achieve this. One obvious mechanism is to embed the receipt in the unprotected header of Target. Another mechanism may be to store both artifacts separately and use a naming convention, database, or other method to link both together.

2. Extract body_protected, payload, and signature from Target.

3. Create a Countersign_structure using the extracted fields from Target, and sign_protected from the receipt data. This is LeafEntryData.

# Receipts      {#receipts}

A Receipt is an inclusion proof for a leaf backed by a signed tree root. It can be considered as efficient batch signing that allows to present each signed payload (leaf) in an individual message suitable for independent verification.

## Receipt Structure

The Receipt structure is a CBOR array. The fields of the array in order are:

- signature: The signature over the Merkle tree root as bstr.

- x5chain: X.509 certificate chain excluding the Root CA certificate as an array of DER-encoded X.509 certificates. The first certificate must be the one whose private key was used to compute the signature. An empty array means that there is no certificate hierarchy.

- inclusion_proof: The Merkle proof for the leaf as an array of \[left, hash\] pairs.

- leaf_info: Information about the leaf that is needed to reconstruct LeafEntryData.

The CDDL fragment that represents the above text for SCITT_Receipt follows.

~~~ cddl
Receipt = [
    signature: bstr,
    x5chain: [ bstr ],
    inclusion_proof: [+ ProofElement],
    leaf_info: LeafInfo
]

ProofElement = [
    left: bool
    hash: bstr
]

LeafInfo = [
    prefix: bstr,
    type: LeafEntryType,
    data: LeafReceiptData
]
~~~

## Receipt Verification

The following steps must be followed to verify a Receipt:

1. Compute LeafEntryData according to the LeafEntryType.

2. Construct a LeafEntry structure and fill it with LeafEntryType and LeafEntryData.

3. Compute LeafBytes as concatenation of prefix and LeafEntryBytes, where LeafEntryBytes is created by encoding LeafEntry to a byte string, using the encoding described in {{deterministic-cbor}}.

        LeafBytes := prefix + LeafEntryBytes

4. Compute the leaf hash from LeafBytes using the Merkle Tree Hash Algorithm found in the log's parameters (see {{parameters}}).

        LeafHash := HASH(LeafBytes)

5. Compute the root hash from the leaf hash and the Merkle proof using the Merkle Tree Hash Algorithm found in the log's parameters (see {{parameters}}):

        h := LeafHash
        for [left, hash] in proof:
            h := HASH(hash + h) if left
                 HASH(h + hash) else
        root := h

6. Verify the signature with the root hash as payload using the certificate chain included in the receipt and the Root CA certificate from the log's parameters (see {{parameters}}).

## SCITT Countersign Receipt

A SCITT Countersign Receipt is a receipt where the leaf entry type is 1 (COSE_Sign1 Countersign type).

~~~
SCITT_Countersign_Receipt = Receipt
~~~

# CBOR Encoding Restrictions    {#deterministic-cbor}

In order to always regenerate the same byte string for the "to be signed" and "to be hashed" values, the core deterministic encoding rules defined in {{Section 4.2.1 of RFC8949}} MUST be used.

# Privacy Considerations

Privacy Considerations

# Security Considerations

Security Considerations

# IANA Considerations

## Additions to Existing Registries

### New Entry to the COSE Header Parameters Registry

IANA is requested to register the new COSE Header parameter defined below in the "COSE Header Parameters" registry. The new parameter is used for embedding one or more SCITT Countersign Receipts in the unprotected header of a COSE message.

Name: SCITT Countersign receipt

Label: TBD

Value Type: SCITT_Countersign_Receipt / \[+ SCITT_Countersign_Receipt\]

Description: A SCITT Countersign Receipt to be embedded in the unprotected header of the countersigned COSE_Sign1 message.

## New SCITT-Related Registries

IANA is asked to add a new registry "TBD" to the list that appears at https://www.iana.org/assignments/.

The rest of this section defines the subregistries that are to be created within the new "TBD" registry.

### Hash Algorithms    {#hash-alg-registry}

IANA is asked to establish a registry of hash algorithm identifiers, named "Hash Algorithms", with the following registration procedures: TBD

The "Hash Algorithms" registry initially consists of:

| Identifier | Hash Algorithm | Reference   |
| SHA-256    | SHA-256        | {{RFC6234}} |
{: title="Initial content of Hash Algorithms registry"}

The designated expert(s) should ensure that the proposed algorithm has a public specification and is suitable for use as a cryptographic hash algorithm with no known preimage or collision attacks. These attacks can damage the integrity of the log.

### Signature Algorithms     {#sig-alg-registry}

IANA is asked to establish a registry of signature algorithm identifiers, named "Signature Algorithms", with the following registration procedures: TBD

The "Signature Algorithms" registry initially consists of:

| Identifier | Signature Algorithm | Reference |
| ES256      | Deterministic ECDSA (NIST P-256) with HMAC-SHA256 | {{RFC6979}} |
| ED25519    | Ed25519 (PureEdDSA with the edwards25519 curve)  | {{RFC8032}} |
{: title="Initial content of Signature Algorithms registry"}

The designated expert(s) should ensure that the proposed algorithm has a public specification and is suitable for use as a cryptographic signature algorithm.

--- back

